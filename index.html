<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>Programación funcional en Perl 6</title>
    
    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/extra.css">
    <link rel="stylesheet" href="css/theme/sky.css">
    
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">
    
    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
	<section><h1>Perl 6 y la programación funcional</h1></section>
	<section> <img
    src='https://farm8.staticflickr.com/7914/46806908884_b4df834428_k_d.jpg'
    alt='selfie'>
          <aside
            class='notes'>¿Quién soy yo?. Programador en Perl desde
    1993, en Perl 6 desde 2016. Documentador-en-jefe de Perl 6, aunque
    no existe esa posición y en realidad no soy jefe de nadie, sólo el
    que se encarga de la documentación; también fui becario de la Perl
    Foundation para encargarme de ella.</aside></section>

        
	<section data-background='https://live.staticflickr.com/1812/30183360848_d06e0a11ce_k_d.jpg'>
	  <h1 class='fragment'>Perl 6 es compilado</h2>
	  <h2 class='fragment'>✓ Multiparadigma</h2>
	  <h2 class='fragment'>✓ Concurrente</h2>
	  <aside class='notes'>Tiene soporte pleno Unicode,
    gramáticas, y un enfoque coherente. Como lenguaje multiparadigma,
    tiene prácticamente todo: orientación a objetos con traits y un
    protocolo para creación de objetos, y es soherente en todos sus
    aspectos. Lo mejor es probarlo para asegurarse. Tiene una buena
    cantidad de libros que lo apoyan, incluyendo el mío, "Learning to
    program with Perl 6" y el siguiente mío, "Perl 6 quick reference",
            que saldrá en APress antes de final de año con un poco de suerte</aside>
	</section>
        
	<section data-background='https://live.staticflickr.com/1057/1008475616_cad7d6a780_b_d.jpg'>
	  <h1>Perl 6 empezó en Haskell</h1>
	  <aside class='notes'>PUGS, el primer intérprete de Perl 6,
	  lo escribió Audrey Tang en Haskell; ella escribió también
	  uno de los primeros trabajos describiendo el diseño del
	  lenguaje</aside> 
	</section>

	<section>
	  <section data-background='https://live.staticflickr.com/7921/46812657474_b8d0df40aa_o_d.jpg'><h1>Las mónadas me atrajeron a Perl 6</h1>
	    <aside class='notes'>Las mónadas, según <a
	  href='https://tanami.org/monads/'>esto</a>, hacen dos cosas:
	  simulan estado y además permiten ordenar funciones (ya que
	  en programación funcional las funciones son
	  <em>puras</em>. Pero el tema es que un día, después de algún
	  tutorial de Haskell donde me enteré de un épsilon más que en
	  el anterior, me dije
	  "Hum. ¿Podrán implementarse mónadas en Perl 6?". Encontré un
	  fichero creado por esta persona, Larry Wall. Era muy
	  antiguo, para versiones iniciales de Perl 6, en concreto,
	  las escritas para Pugs, y no funcionaba. Lo arreglé, hice
	  pull request, y de repente me dieron el commit bit. Y es que
	  Perl 6 se estuvo desarrollando durante 15 años hasta que se
	  produjo la primera versión estable. Durante 15 años iba a
	  estar listo para navidad, pero no se dijo de qué año. Larry
	  Wall creó Perl en los 80 y fue evolucionando hasta Perl 5,
	  que se sigue usando ahora. Perl 6 va mucho más allá. Larry
	  Wall dice que existe la misma relación entre ambos que entre
	  el Hobbit y el Señor de los Anillos. Están en el mismo
	  mundo, son lenguajes hermanos, están en la misma
	  comunidad. Pero como Charmander y Charmeleon, es una
	  evolución uno de otro.
	    </aside>
	  </section>

        </section>

        <section>
          <section>
            <h1>Procesando listas</h1>
            <pre><code>(1..10).map( *²).say;</code></pre>
            <pre class='fragment'><code>(1..10).map( *²).grep( * ≥ 12 ).say;</code></pre>
            <pre class='fragment'><code>1..10 ==> map( *²) ==> grep( * ≥ 12 ) ==> my @output;
@output.join( " ⬖ ").put;</code></pre>

            <aside class='notes'>Tomado de <a
        href='http://learnyouahaskell.com/starting-out#im-a-list-comprehension'>Learn
            you a Haskell for Great Good</a>, la sintaxis es algo
        diferente, pero casi igual de compacta y funcionalmente
        similar. También se exhibe el "Whatever", que se usa para
        crear código on the fly, el uso de Unicode como operadores, y
              el operador "rocket" que mola mucho. 1..10 es un Range,
        igual que en Haskell. Perl 6 usa duck typing. El operador
        rocket hace lo que parece qu ehace, pero en realidad pasa su
        lado derecho como segundo argumento a la función en su derecha.</aside>
          </section>

          <section><h1>TIMTOWTDI</h1>
            <pre><code>#!/usr/bin/env perl6
use v6;
((1..10) »**» 2 ).duckmap: -> $x where * ≥ 12 { $x.say };
=output
16
25
....</code></pre>

            <aside class='notes'>Siempre varias formas de hacerlo,
          pero aquí muestro el script completo. Funciona como un
          intérprete aunque internamente es un compilador JIT. Uso un
          gestor de versiones, que me instala las versiones que van
          apareciendo, periodicidad mensual. use v6 espanta a perl5 y
          da un error. Usamos el hiper-operador, que aplica el
          operador que tiene dentro, en este caso la exponenciación. Y
          duckmap mola mucho: aplica la expresión, siempre que se
          cumpla la signatura, en este caso de un pointy block. Otra
          forma de filtrar... Aparte, el bloque =output es un bloque
          de comentarios, pero tienen un nombre y podemos usarlo más
              adelante para testear.</aside>
          </section>

          <section><h1>Sin test == Roto</h1>
            <pre><code>language: minimal
services:
  - docker
install:
  - docker pull jjmerelo/perl6-test-script-output
  - mkdir t \
      && echo "use Test::Script::Output;for &lt;code> \
      -> \$d { dir-ok( \$d.IO , 'Scripts in dir ' ~ \$d ~ ' are OK') }" \
      > t/0.t
script: docker run -t -v \
      $TRAVIS_BUILD_DIR:/test jjmerelo/perl6-test-script-output</code></pre>
            <aside class='notes'>Se trata de un módulo de Perl 6 que
            se descarga del ecosistema y sirve para testear las
            salidas de scripts. Lo escribí para el libro en el que
            estoy trabajando. Pero muestra los PODs, o comentarios con
            esteroides, y las posibilidades que ofrece Perl 6 para
              introspección de código</aside>
          </section>
        </section>

        <section>
          <section><h1>Tipos</h1>
            <pre><code>sub quita-no-mayúsculas( Str $cadena &dash;&dash;> Seq ) {
    return $cadena.comb.grep: * ∉ 'A'..'Z';
}
say quita-no-mayúsculas( "LaTeX" );
say quita-no-mayúsculas( "Learn You a Haskell" );
say &quita-no-mayúsculas.^name # Sub+{Callable[Seq]}
            </code></pre>

            <aside class='notes'>Aparte del formato del nombre y del
          hecho de que podemos usar operadores Unicode, lo interesante
          es una llamada a la meta-clase en forma de name, que nos
              devuelve el tipo y el rol que implementa esa función. Es
              un rol además parametrizado por el tipo que devuelve la función</aside>
          </section>

          <section><h1><em>Typeclasses</em></h1>
	    <pre><code>sub þor( Int, Int &dash;&dash;&gt; Str ) {};
say &þor.^name; # Sub+{Callable[Str]}
say &þor.^mro;
#((Sub+{Callable[Str]}) (Sub) (Routine) (Block) (Code) (Any) (Mu))
	    </code></pre>         <aside class='notes'><a
            href='https://dev.to/jj/assuming-roles-2dog'>Aquí hablo
              sobre roles y mixins</a>. Aparentemente, las typeclasses
              son como roles abstractos.</aside>
          </section>

	  <section><pre><code>role CasiEq {
    method  casi-igual( \rhs &dash;&dash;&gt; Bool) {...}
    method  casi-diferente( \rhs &dash;&dash;&gt; Bool) {...}
}
class CasiEqInt does CasiEq {
    has Int $.n;
    method casi-igual ( \rhs &dash;&dash;&gt; Bool) { return True if abs($!n - rhs) ≤ 1 }
    method casi-diferente ( \rhs &dash;&dash;&gt; Bool) { True unless abs($!n - rhs) ≤ 1}
    method Numeric( &dash;&dash;&gt; Numeric:D ) { return $!n }
}
my $n1 := CasiEqInt.new( n => 1 );
my $n2 := CasiEqInt.new( n => 2 );
say "Casi " if $n1.casi-igual($n2);
</pre></code>
	  </section>

	  <section><h1>O con protos/multi</h1>
	    <pre><code>proto sub infix:&lt;≈&gt; ( | &dash;&dash;&gt; Bool) {*} </code></pre>

	    <pre class='fragment'><code>multi sub infix:&lt;≈&gt; ( Int $lhs, Int $rhs &dash;&dash;&gt; Bool) { return True if abs( $lhs - $rhs) ≤ 1 }</code></pre>

	    <pre class='fragment'><code>say "Casi " if 3 ≈ 2 ;</code></pre>
	  </section>
	</section>
	
	<section> <!-- Funciones -->
	  <section><h1>Emparejando patrones</h1>
<pre><code>proto sub lucky (Int \a &dash;&dash;&gt; Str ) { *}
multi sub lucky ( 7 ) {  "LUCKY NUMBER SEVEN!" }
multi sub lucky ( $x where * ≠ 7 ) { "Sorry, you're out of luck, pal!" };
				     
say lucky 7 ;
say lucky 33;</code></pre>
<aside class='notes'>Prácticamente igual que http://learnyouahaskell.com/syntax-in-functions</aside>
	  </section>
	  <section><h1><em>Higher order functions</em></h1>
	    <pre><code>sub mult-three( \a, \b, \c ) {
    return a * b * c;
}
my &mult-two-with-nine = &mult-three.assuming( *, *, 9);
say mult-two-with-nine 2, 3;</code></pre>

	    <aside class='notes'>Whatever y assumming permiten currificar todo lo que haga falta.</aside>
	  </section>
	<section><h1><em>Currying</em></h1></section>
        <section><h1>Mónadas</h1>
	    <pre><code># return :: (Monad m) => a -&gt; m a
sub mreturn($a --&gt; Code ) { return { $a } }
	    </code></pre>
	  </section>


	<section>
	  <ul class='credits'>
	    <li>Foto de Audrey Tang de <a href='https://flic.kr/p/2x7GEC'>Yoshinori Takesako</a></li>
	  </ul>
      </div>
    </div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
			width: '95%',
			controls: true,
			progress: true,
			history: true,
				dependencies: [
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>
